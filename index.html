<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiByeD0iMjI5IiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMF8xKSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzBfMSIgeDE9IjAiIHkxPSIwIiB4Mj0iMTAyNCIgeTI9IjEwMjQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzZCNzNGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM5Q0E3RkYiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K">
    <title>360째 Photosphere Capture</title>
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIjM2MMKwIFBob3Rvc3BoZXJlIENhcHR1cmUiLAogICJzaG9ydF9uYW1lIjogIlBob3Rvc3BoZXJlIiwKICAiZGVzY3JpcHRpb24iOiAiQVIgZW5hYmxlZCAzNjDCsCBwaG90b3NwaGVyZSBjYXB0dXJlIGFwcCIsCiAgInN0YXJ0X3VybCI6ICIvIiwKICAiZGlzcGxheSI6ICJmdWxsc2NyZWVuIiwKICAib3JpZW50YXRpb24iOiAicG9ydHJhaXQiLAogICJ0aGVtZV9jb2xvciI6ICIjMkEyQTJBIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjMkEyQTJBIiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpVMklpQm9aV2xuYUhROUlqSTFOaUlnZG1sbGQwSnZlRDBpTUNBd0lESTFOaUF5TlRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1eklEMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lQZ289IiwKICAgICAgInNpemVzIjogIjI1NngyNTYiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0KfQ==">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            color: white;
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .home-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
            padding: 20px;
        }

        .app-title {
            background: linear-gradient(135deg, #6B73FF 0%, #9CA7FF 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            letter-spacing: -0.02em;
        }

        .app-subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 3rem;
            font-weight: 300;
        }

        .version {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 0.9rem;
            opacity: 0.6;
        }

        .start-button {
            background: linear-gradient(135deg, #6B73FF 0%, #9CA7FF 100%);
            border: none;
            border-radius: 50px;
            padding: 20px 40px;
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(107, 115, 255, 0.3);
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 48px rgba(107, 115, 255, 0.4);
        }

        .start-button:active {
            transform: translateY(0);
        }

        .capture-screen {
            display: none;
            position: relative;
            height: 100vh;
            background: #000;
        }

        .camera-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 3px solid white;
            border-radius: 50%;
            opacity: 0.8;
            pointer-events: none;
        }

        .guidance-dot {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #4285f4;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .guidance-dot.captured {
            background: #34a853;
            transform: scale(0.8);
        }

        .guidance-dot.active {
            background: #ff9800;
            transform: scale(1.3);
            box-shadow: 0 0 20px #ff9800;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .control-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .capture-button {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #6B73FF 0%, #9CA7FF 100%);
        }

        .status-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .progress-ring {
            width: 120px;
            height: 120px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .progress-ring-circle {
            fill: none;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 4;
        }

        .progress-ring-progress {
            fill: none;
            stroke: #6B73FF;
            stroke-width: 4;
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dashoffset 0.3s ease;
        }

        .captured-image {
            position: absolute;
            width: 60px;
            height: 40px;
            border: 2px solid white;
            border-radius: 4px;
            opacity: 0.8;
            transform: scale(0.8);
            object-fit: cover;
            pointer-events: none;
        }

        .processing-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .processing-text {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #6B73FF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .viewer-screen {
            display: none;
            position: relative;
            height: 100vh;
        }

        #photosphere-viewer {
            width: 100%;
            height: 100%;
        }

        .viewer-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .hidden {
            display: none !important;
        }

        .visible {
            display: flex !important;
        }

        .instruction-text {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            text-align: center;
            max-width: 280px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Home Screen -->
        <div class="home-screen" id="homeScreen">
            <h1 class="app-title">360째 Photosphere</h1>
            <p class="app-subtitle">AR-Enhanced Panoramic Photography</p>
            <button class="start-button" onclick="requestPermissions()">Start Capture</button>
            <div class="version">v4.2.0</div>
        </div>

        <!-- Capture Screen -->
        <div class="capture-screen" id="captureScreen">
            <video class="camera-feed" id="cameraFeed" autoplay playsinline></video>
            
            <div class="ar-overlay" id="arOverlay">
                <div class="crosshair"></div>
                <div class="instruction-text" id="instructionText">Point the camera at the orange dot</div>
                
                <!-- Progress Ring -->
                <svg class="progress-ring" id="progressRing">
                    <circle class="progress-ring-circle" cx="60" cy="60" r="54"></circle>
                    <circle class="progress-ring-progress" id="progressCircle" cx="60" cy="60" r="54" 
                            stroke-dasharray="339.292" stroke-dashoffset="339.292"></circle>
                </svg>
            </div>

            <div class="status-bar">
                <span id="captureCount">0/12 captured</span>
                <span id="compassHeading">Compass: 0째</span>
            </div>

            <div class="controls">
                <button class="control-button" onclick="goHome()" title="Home">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
                    </svg>
                </button>
                <button class="control-button capture-button" onclick="capturePhoto()" title="Capture">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="12" cy="12" r="3.2"/>
                        <path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
                    </svg>
                </button>
                <button class="control-button" onclick="completeCapture()" title="Complete">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Processing Screen -->
        <div class="processing-screen" id="processingScreen">
            <div class="processing-text">Stitching panorama...</div>
            <div class="spinner"></div>
        </div>

        <!-- Viewer Screen -->
        <div class="viewer-screen" id="viewerScreen">
            <div id="photosphere-viewer"></div>
            <div class="viewer-controls">
                <button class="control-button" onclick="savePhoto()" title="Save">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
                    </svg>
                </button>
                <button class="control-button" onclick="goHome()" title="New Capture">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Include Three.js for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Include Photo Sphere Viewer for panorama display -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/photo-sphere-viewer/4.8.1/photo-sphere-viewer.min.js"></script>

    <script>
        // App State
        let currentScreen = 'home';
        let cameraStream = null;
        let capturedImages = [];
        let guidanceDots = [];
        let currentDotIndex = 0;
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        let photosphereViewer = null;

        // Sphere positions for guidance dots (12 positions covering most of sphere)
        const dotPositions = [
            { pitch: 0, yaw: 0, label: 'North' },
            { pitch: 0, yaw: 60, label: 'NE' },
            { pitch: 0, yaw: 120, label: 'SE' },
            { pitch: 0, yaw: 180, label: 'South' },
            { pitch: 0, yaw: 240, label: 'SW' },
            { pitch: 0, yaw: 300, label: 'NW' },
            { pitch: 45, yaw: 0, label: 'Up N' },
            { pitch: 45, yaw: 180, label: 'Up S' },
            { pitch: -45, yaw: 0, label: 'Down N' },
            { pitch: -45, yaw: 180, label: 'Down S' },
            { pitch: 90, yaw: 0, label: 'Zenith' },
            { pitch: -90, yaw: 0, label: 'Nadir' }
        ];

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            setupServiceWorker();
            checkWebXRSupport();
        });

        // Service Worker for PWA functionality
        function setupServiceWorker() {
            // Skip service worker registration in this environment to avoid blob URL issues
            console.log('PWA features available - Service Worker would be registered in production');
        }

        // Check WebXR support safely
        function checkWebXRSupport() {
            try {
                if ('xr' in navigator && navigator.xr) {
                    navigator.xr.isSessionSupported('immersive-ar').then(supported => {
                        console.log('WebXR AR supported:', supported);
                    }).catch(error => {
                        console.log('WebXR AR check failed:', error.message);
                    });
                } else {
                    console.log('WebXR not available');
                }
            } catch (error) {
                console.log('WebXR support check skipped:', error.message);
            }
        }

        // New function to handle permission requests step by step
        async function requestPermissions() {
            const button = document.querySelector('.start-button');
            const originalText = button.textContent;
            
            try {
                // Step 1: Request orientation permission (iOS)
                button.textContent = 'Requesting Motion Permission...';
                
                if (typeof DeviceOrientationEvent !== 'undefined' && 
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    
                    const orientationPermission = await DeviceOrientationEvent.requestPermission();
                    console.log('Orientation permission:', orientationPermission);
                    
                    if (orientationPermission !== 'granted') {
                        button.textContent = originalText;
                        alert('Motion & Orientation access is required for AR guidance.\n\nPlease:\n1. Tap "Start Capture" again\n2. Allow motion access when prompted\n3. Grant camera permission');
                        return;
                    }
                    
                    setupOrientationTracking();
                } else {
                    // Non-iOS devices
                    console.log('Orientation permission not required on this device');
                    setupOrientationTracking();
                }
                
                // Step 2: Request camera permission
                button.textContent = 'Requesting Camera Permission...';
                await startCapture();
                
            } catch (error) {
                button.textContent = originalText;
                console.error('Permission error:', error);
                
                if (error.name === 'NotAllowedError') {
                    alert('Permissions were denied. Please:\n1. Refresh the page\n2. Grant motion permission when prompted\n3. Grant camera permission when prompted');
                } else {
                    alert('Error requesting permissions: ' + error.message);
                }
            }
        }

        // Request permissions and start capture
        async function startCapture() {
            try {
                console.log('Requesting camera permission...');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                
                console.log('Camera permission granted');
                cameraStream = stream;
                document.getElementById('cameraFeed').srcObject = stream;
                
                showCaptureScreen();
                setupGuidanceDots();
                
            } catch (error) {
                console.error('Error starting capture:', error);
                
                // More specific error messages
                if (error.name === 'NotAllowedError') {
                    alert('Camera permission was denied.\n\nPlease:\n1. Refresh the page\n2. Allow camera access when prompted');
                } else if (error.name === 'NotFoundError') {
                    alert('No camera found on this device.');
                } else if (error.name === 'NotSupportedError') {
                    alert('Camera access is not supported on this device.');
                } else {
                    alert('Unable to access camera: ' + error.message);
                }
                
                // Reset button
                const button = document.querySelector('.start-button');
                button.textContent = 'Start Capture';
            }
        }

        // Setup device orientation tracking
        function setupOrientationTracking() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', handleOrientation, true);
                window.addEventListener('deviceorientationabsolute', handleOrientation, true);
            }
        }

        // Handle device orientation changes
        function handleOrientation(event) {
            deviceOrientation.alpha = event.alpha || 0;
            deviceOrientation.beta = event.beta || 0;
            deviceOrientation.gamma = event.gamma || 0;
            
            // Update compass heading display
            let heading = event.webkitCompassHeading || event.alpha || 0;
            document.getElementById('compassHeading').textContent = `Compass: ${Math.round(heading)}째`;
            
            updateGuidanceDots();
        }

        // Show capture screen
        function showCaptureScreen() {
            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('captureScreen').style.display = 'block';
            currentScreen = 'capture';
        }

        // Setup guidance dots in AR overlay
        function setupGuidanceDots() {
            const overlay = document.getElementById('arOverlay');
            guidanceDots = [];
            
            dotPositions.forEach((pos, index) => {
                const dot = document.createElement('div');
                dot.className = 'guidance-dot';
                dot.dataset.index = index;
                dot.onclick = () => setActiveDot(index);
                overlay.appendChild(dot);
                guidanceDots.push({
                    element: dot,
                    position: pos,
                    captured: false
                });
            });
            
            setActiveDot(0);
            updateGuidanceDots();
        }

        // Update guidance dot positions based on orientation
        function updateGuidanceDots() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const radius = Math.min(window.innerWidth, window.innerHeight) * 0.3;
            
            guidanceDots.forEach((dot, index) => {
                const pos = dot.position;
                
                // Convert spherical coordinates to screen coordinates
                // This is a simplified projection
                const yawRad = (pos.yaw - deviceOrientation.alpha) * Math.PI / 180;
                const pitchRad = (pos.pitch - deviceOrientation.beta) * Math.PI / 180;
                
                const x = centerX + Math.sin(yawRad) * radius * Math.cos(pitchRad);
                const y = centerY - Math.sin(pitchRad) * radius;
                
                // Check if dot should be visible (on screen)
                const visible = x > 0 && x < window.innerWidth && y > 0 && y < window.innerHeight;
                
                dot.element.style.left = x + 'px';
                dot.element.style.top = y + 'px';
                dot.element.style.display = visible ? 'block' : 'none';
                
                // Check if user is pointing at the active dot (auto-capture)
                if (index === currentDotIndex && !dot.captured) {
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    if (distance < 50) { // Close enough to crosshair
                        setTimeout(() => {
                            if (index === currentDotIndex && !dot.captured) {
                                capturePhoto();
                            }
                        }, 1000); // Auto-capture after 1 second
                    }
                }
            });
        }

        // Set active guidance dot
        function setActiveDot(index) {
            guidanceDots.forEach(dot => dot.element.classList.remove('active'));
            if (guidanceDots[index] && !guidanceDots[index].captured) {
                guidanceDots[index].element.classList.add('active');
                currentDotIndex = index;
            }
        }

        // Capture photo
        function capturePhoto() {
            if (guidanceDots[currentDotIndex].captured) return;
            
            const video = document.getElementById('cameraFeed');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            
            const imageData = canvas.toDataURL('image/jpeg', 0.9);
            
            // Store captured image with metadata
            capturedImages.push({
                data: imageData,
                orientation: { ...deviceOrientation },
                position: dotPositions[currentDotIndex],
                timestamp: Date.now()
            });
            
            // Mark dot as captured
            guidanceDots[currentDotIndex].captured = true;
            guidanceDots[currentDotIndex].element.classList.add('captured');
            guidanceDots[currentDotIndex].element.classList.remove('active');
            
            // Show captured image preview
            showCapturedImagePreview(imageData, currentDotIndex);
            
            // Update progress
            updateProgress();
            
            // Move to next uncaptured dot
            findNextDot();
        }

        // Show captured image preview
        function showCapturedImagePreview(imageData, index) {
            const overlay = document.getElementById('arOverlay');
            const preview = document.createElement('img');
            preview.className = 'captured-image';
            preview.src = imageData;
            
            // Position preview near the captured dot
            const dot = guidanceDots[index];
            const dotRect = dot.element.getBoundingClientRect();
            preview.style.left = (dotRect.left - 30) + 'px';
            preview.style.top = (dotRect.top - 20) + 'px';
            
            overlay.appendChild(preview);
        }

        // Update capture progress
        function updateProgress() {
            const capturedCount = capturedImages.length;
            const totalCount = dotPositions.length;
            const progress = capturedCount / totalCount;
            
            document.getElementById('captureCount').textContent = `${capturedCount}/${totalCount} captured`;
            
            // Update progress ring
            const circle = document.getElementById('progressCircle');
            const circumference = 2 * Math.PI * 54;
            const offset = circumference - (progress * circumference);
            circle.style.strokeDashoffset = offset;
        }

        // Find next uncaptured dot
        function findNextDot() {
            for (let i = 0; i < guidanceDots.length; i++) {
                if (!guidanceDots[i].captured) {
                    setActiveDot(i);
                    return;
                }
            }
            
            // All dots captured
            document.getElementById('instructionText').textContent = 'All positions captured! Tap Complete to stitch panorama.';
        }

        // Complete capture and start stitching
        function completeCapture() {
            if (capturedImages.length === 0) {
                alert('Please capture at least one image before completing.');
                return;
            }
            
            showProcessingScreen();
            setTimeout(() => {
                stitchPanorama();
            }, 1000);
        }

        // Show processing screen
        function showProcessingScreen() {
            document.getElementById('processingScreen').style.display = 'flex';
        }

        // Hide processing screen
        function hideProcessingScreen() {
            document.getElementById('processingScreen').style.display = 'none';
        }

        // Stitch panorama (simplified implementation)
        function stitchPanorama() {
            try {
                // Create a large canvas for the equirectangular panorama
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Standard equirectangular dimensions (2:1 ratio)
                canvas.width = 2048;
                canvas.height = 1024;
                
                // Fill with black background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Process each captured image
                const promises = capturedImages.map((capture, index) => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            // Calculate position on equirectangular projection
                            const pos = capture.position;
                            
                            // Convert spherical coordinates to equirectangular coordinates
                            const x = ((pos.yaw + 180) / 360) * canvas.width;
                            const y = ((90 - pos.pitch) / 180) * canvas.height;
                            
                            // Calculate image size based on field of view
                            const imageWidth = canvas.width / 6; // Approximate FOV coverage
                            const imageHeight = canvas.height / 6;
                            
                            // Draw image with some overlap blending
                            ctx.globalAlpha = 0.8;
                            ctx.drawImage(img, 
                                x - imageWidth/2, 
                                y - imageHeight/2, 
                                imageWidth, 
                                imageHeight
                            );
                            
                            resolve();
                        };
                        img.src = capture.data;
                    });
                });
                
                // Wait for all images to be processed
                Promise.all(promises).then(() => {
                    const panoramaData = canvas.toDataURL('image/jpeg', 0.9);
                    hideProcessingScreen();
                    showViewer(panoramaData);
                });
                
            } catch (error) {
                console.error('Error stitching panorama:', error);
                hideProcessingScreen();
                alert('Error creating panorama. Please try again.');
            }
        }

        // Show panorama viewer
        function showViewer(panoramaData) {
            document.getElementById('captureScreen').style.display = 'none';
            document.getElementById('viewerScreen').style.display = 'block';
            currentScreen = 'viewer';
            
            // Stop camera stream
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            // Initialize Photo Sphere Viewer
            if (photosphereViewer) {
                photosphereViewer.destroy();
            }
            
            try {
                photosphereViewer = new PhotoSphereViewer.Viewer({
                    container: document.getElementById('photosphere-viewer'),
                    panorama: panoramaData,
                    loadingImg: null,
                    navbar: false,
                    defaultZoomLvl: 50,
                    minFov: 30,
                    maxFov: 90,
                    touchmoveTwoFingers: true,
                    mousewheelCtrlKey: true
                });
            } catch (error) {
                console.error('Error initializing viewer:', error);
                // Fallback: create simple viewer
                createFallbackViewer(panoramaData);
            }
        }

        // Fallback viewer using basic canvas
        function createFallbackViewer(panoramaData) {
            const container = document.getElementById('photosphere-viewer');
            container.innerHTML = '';
            
            const img = document.createElement('img');
            img.src = panoramaData;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            container.appendChild(img);
        }

        // Save panorama to device
        function savePhoto() {
            if (!photosphereViewer && !document.querySelector('#photosphere-viewer img')) {
                alert('No panorama to save.');
                return;
            }
            
            try {
                // Get the panorama data
                let panoramaData;
                if (photosphereViewer) {
                    panoramaData = photosphereViewer.getConfig().panorama;
                } else {
                    panoramaData = document.querySelector('#photosphere-viewer img').src;
                }
                
                // Create download link
                const link = document.createElement('a');
                link.href = panoramaData;
                link.download = `photosphere_${new Date().getTime()}.jpg`;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Also try to save to Photos app on iOS (if supported)
                if (navigator.share && navigator.canShare) {
                    fetch(panoramaData)
                        .then(res => res.blob())
                        .then(blob => {
                            const file = new File([blob], 'photosphere.jpg', { type: 'image/jpeg' });
                            if (navigator.canShare({ files: [file] })) {
                                navigator.share({ files: [file] });
                            }
                        })
                        .catch(console.error);
                }
                
            } catch (error) {
                console.error('Error saving photo:', error);
                alert('Error saving photo. Please try again.');
            }
        }

        // Go back to home screen
        function goHome() {
            // Stop camera stream
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            // Destroy viewer
            if (photosphereViewer) {
                photosphereViewer.destroy();
                photosphereViewer = null;
            }
            
            // Reset state
            capturedImages = [];
            guidanceDots = [];
            currentDotIndex = 0;
            
            // Clear overlays
            const overlay = document.getElementById('arOverlay');
            const previews = overlay.querySelectorAll('.captured-image');
            previews.forEach(preview => preview.remove());
            
            const dots = overlay.querySelectorAll('.guidance-dot');
            dots.forEach(dot => dot.remove());
            
            // Show home screen
            document.getElementById('captureScreen').style.display = 'none';
            document.getElementById('viewerScreen').style.display = 'none';
            document.getElementById('processingScreen').style.display = 'none';
            document.getElementById('homeScreen').style.display = 'flex';
            currentScreen = 'home';
            
            // Reset progress
            document.getElementById('captureCount').textContent = '0/12 captured';
            document.getElementById('progressCircle').style.strokeDashoffset = '339.292';
        }

        // Handle orientation changes
        window.addEventListener('orientationchange', function() {
            setTimeout(updateGuidanceDots, 100);
        });

        // Handle page visibility for battery optimization
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && cameraStream) {
                // Pause camera when app is not visible
                const video = document.getElementById('cameraFeed');
                video.srcObject = null;
            } else if (!document.hidden && cameraStream && currentScreen === 'capture') {
                // Resume camera when app becomes visible
                const video = document.getElementById('cameraFeed');
                video.srcObject = cameraStream;
            }
        });

        // Prevent zoom on double tap (iOS Safari)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Handle device motion for enhanced AR tracking (if available)
        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', function(event) {
                // Use accelerometer data for smoother tracking
                // This could be enhanced with more sophisticated filtering
                const acceleration = event.acceleration;
                if (acceleration) {
                    // Implement motion smoothing if needed
                }
            });
        }

        // Error handling for camera issues
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            // Don't show alerts for every error, just log them
        });

        // Check for updates (PWA update mechanism)
        function checkForUpdates() {
            // Simplified update check without service worker
            console.log('Update check - would use service worker in production');
        }

        // Handle WebXR AR if available (enhanced AR mode)
        async function tryWebXRAR() {
            try {
                if ('xr' in navigator && navigator.xr) {
                    const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (isSupported) {
                        const session = await navigator.xr.requestSession('immersive-ar');
                        // Enhanced AR implementation would go here
                        console.log('WebXR AR session started');
                        return session;
                    }
                }
            } catch (error) {
                console.log('WebXR AR not available:', error.message);
            }
            return null;
        }

        // Enhanced compass calibration for better accuracy
        function calibrateCompass() {
            if (typeof DeviceOrientationEvent !== 'undefined') {
                // Listen for compass calibration events
                window.addEventListener('compassneedscalibration', function(event) {
                    alert('Your compass needs calibration. Please move your device in a figure-8 motion.');
                    event.preventDefault();
                }, true);
            }
        }

        // Initialize compass calibration
        calibrateCompass();

        // Performance optimization: throttle orientation updates
        let orientationUpdateTimeout;
        function throttledOrientationUpdate() {
            if (orientationUpdateTimeout) return;
            orientationUpdateTimeout = setTimeout(() => {
                updateGuidanceDots();
                orientationUpdateTimeout = null;
            }, 16); // ~60fps
        }

        // Override the original handleOrientation to use throttling
        const originalHandleOrientation = handleOrientation;
        handleOrientation = function(event) {
            originalHandleOrientation(event);
            throttledOrientationUpdate();
        };

    </script>
</body>
</html>